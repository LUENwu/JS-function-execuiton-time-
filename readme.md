# JS 函数的执行时机
### 规则：同步优先、异步靠边、回调垫底
```
let i = 0
for(i = 0; i<6; i++){
 setTimeout(()=>{   
 console.log(i)   
},0)
 }
 结果是打印出 6、6、6、6、6、6,怎么不是打印0,1,2,3,4,5呢??
```

* **js的执行机制**:js是单线程环境,由上至下,依次执行,即同步执行;
for循环是同步代码,而setTimeout是异步代码.js在执行代码过程中,碰到同步代码会依次执行,碰到异步代码会将其放入任务队列进行等待,待同步代码执行完毕后再开始执行异步代码,即异步执行.
* **js的作用域**:当同步代码执行完成后,准备执行异步的setTimeout,执行setTimeout需要从当前作用域寻找变量**i**,此时for循环已执行完毕,当前的变量**i=6**,所以setTimeout输出为6,for循环共执行了6次,任务队列中的5个setTimeout也依次执行,皆为6.

```
for(let i = 0; i<6; i++){
setTimeout(()=>{
console.log(i)
},0)
} 
结果是打印出 0、1、2、3、4、5
```
* 因为let变量的作用域只能在当前函数中，所以每次for循环生成的都是一个新的i，
setTimeout里输出的i就是这个新的i，这个i是不会变化的，所以输出的就是正常的。
* let只在代码块内才有效,let只能声明一次。变量i是用let声明的，当前的i只在本轮循环中有效，每次循环的i 其实都是一个新的变量，所以setTimeout定时器里面的i,其实是不同的变量，即最后输出0-5。（若每次循环的变量i都是重新声明的，如何知道前一个循环的值？这是因为 JavaScript 引擎内部会记住前一个循环值）

### 除了使用 for let 配合，还有什么其他方法可以打印出 0、1、2、3、4、5？如下：

```
1. while语句

var i = 0
while(i<6){
  console.log(i)
  i+=1
}
```
```
2. 闭包:自执行函数。
使用 ！开头，结构清晰，不容易混乱.

let i = 0
for(i = 0;i<6;i++){
  !function(j){
    setTimeout(()=>{
      console.log(j)
    },0)
  }(i)
}
```
```
3.用数组push()方法
let arr =[]

for(i=0;i<6;i++){
  arr.push(i)
}
console.log(arr)
```
部分资料来自:https://zhuanlan.zhihu.com/p/348475389





























* 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。
* 异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。
